/*=======================================================================================*/
/*  This Sail RISC-V architecture model, comprising all files and                        */
/*  directories except where otherwise noted is subject the BSD                          */
/*  two-clause license in https://github.com/riscv/sail-riscv/blob/master/LICENCE.       */
/*                                                                                       */
/*  SPDX-License-Identifier: BSD-2-Clause                                                */
/*  This file is generated by make_td tool as part of Tristan Project                    */
/*=======================================================================================*/

register imt_mem : vector(1024 * 1024, bits(32))

function clause currentlyEnabled(Ext_Zimt) = hartSupports(Ext_Zimt)


union clause instruction = V2DDEFU8 : (regidx, regidx, mregidx)

mapping clause encdec = V2DDEFU8(rs2, rs1, md)
	
<-> 0b0000001 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_mreg(md) @ 0b0101011
	when currentlyEnabled(Ext_Zimt)

function clause execute(V2DDEFU8(rs2, rs1, md)) = {
	let rs1_val = X(rs1);
	let rs2_val = X(rs2);
	let md_no = mregidx_to_mregno(md);
	var mr = rM(md_no);
	mr.dtype = UINT_8;
	mr.width = rs1_val;
	mr.height = rs2_val;
	wM(md_no, mr);
	RETIRE_SUCCESS
}

mapping clause assembly = V2DDEFU8(rs2, rs1, md)
	
<-> "v2ddefu8" ^ spc() ^ reg_name(rs2) ^ sep() ^ reg_name(rs1) ^ sep() ^ mreg_name(md)
	when currentlyEnabled(Ext_Zimt)

union clause instruction = V2DDEF8 : (regidx, regidx, mregidx)

mapping clause encdec = V2DDEF8(rs2, rs1, md)
	
<-> 0b0000000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_mreg(md) @ 0b0101011
	when currentlyEnabled(Ext_Zimt)

function clause execute(V2DDEF8(rs2, rs1, md)) = {
	let rs1_val = X(rs1);
	let rs2_val = X(rs2);
	let md_no = mregidx_to_mregno(md);
	var mr = rM(md_no);
	mr.dtype = INT_8;
	mr.width = rs1_val;
	mr.height = rs2_val;
	wM(md_no, mr);
	RETIRE_SUCCESS
}

mapping clause assembly = V2DDEF8(rs2, rs1, md)
	
<-> "v2ddef8" ^ spc() ^ reg_name(rs2) ^ sep() ^ reg_name(rs1) ^ sep() ^ mreg_name(md)
	when currentlyEnabled(Ext_Zimt)

union clause instruction = V2DDEFU16 : (regidx, regidx, mregidx)

mapping clause encdec = V2DDEFU16(rs2, rs1, md)
	
<-> 0b0000011 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_mreg(md) @ 0b0101011
	when currentlyEnabled(Ext_Zimt)

function clause execute(V2DDEFU16(rs2, rs1, md)) = {
	let rs1_val = X(rs1);
	let rs2_val = X(rs2);
	let md_no = mregidx_to_mregno(md);
	var mr = rM(md_no);
	mr.dtype = UINT_16;
	mr.width = rs1_val;
	mr.height = rs2_val;
	wM(md_no, mr);
	RETIRE_SUCCESS
}

mapping clause assembly = V2DDEFU16(rs2, rs1, md)
	
<-> "v2ddefu16" ^ spc() ^ reg_name(rs2) ^ sep() ^ reg_name(rs1) ^ sep() ^ mreg_name(md)
	when currentlyEnabled(Ext_Zimt)

union clause instruction = V2DDEF16 : (regidx, regidx, mregidx)

mapping clause encdec = V2DDEF16(rs2, rs1, md)
	
<-> 0b0000010 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_mreg(md) @ 0b0101011
	when currentlyEnabled(Ext_Zimt)

function clause execute(V2DDEF16(rs2, rs1, md)) = {
	let rs1_val = X(rs1);
	let rs2_val = X(rs2);
	let md_no = mregidx_to_mregno(md);
	var mr = rM(md_no);
	mr.dtype = INT_16;
	mr.width = rs1_val;
	mr.height = rs2_val;
	wM(md_no, mr);
	RETIRE_SUCCESS
}

mapping clause assembly = V2DDEF16(rs2, rs1, md)
	
<-> "v2ddef16" ^ spc() ^ reg_name(rs2) ^ sep() ^ reg_name(rs1) ^ sep() ^ mreg_name(md)
	when currentlyEnabled(Ext_Zimt)

union clause instruction = V2DDEFU32 : (regidx, regidx, mregidx)

mapping clause encdec = V2DDEFU32(rs2, rs1, md)
	
<-> 0b0000101 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_mreg(md) @ 0b0101011
	when currentlyEnabled(Ext_Zimt)

function clause execute(V2DDEFU32(rs2, rs1, md)) = {
	let rs1_val = X(rs1);
	let rs2_val = X(rs2);
	let md_no = mregidx_to_mregno(md);
	var mr = rM(md_no);
	mr.dtype = UINT_32;
	mr.width = rs1_val;
	mr.height = rs2_val;
	wM(md_no, mr);
	RETIRE_SUCCESS
}

mapping clause assembly = V2DDEFU32(rs2, rs1, md)
	
<-> "v2ddefu32" ^ spc() ^ reg_name(rs2) ^ sep() ^ reg_name(rs1) ^ sep() ^ mreg_name(md)
	when currentlyEnabled(Ext_Zimt)

union clause instruction = V2DDEF32 : (regidx, regidx, mregidx)

mapping clause encdec = V2DDEF32(rs2, rs1, md)
	
<-> 0b0000100 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b000 @ encdec_mreg(md) @ 0b0101011
	when currentlyEnabled(Ext_Zimt)

function clause execute(V2DDEF32(rs2, rs1, md)) = {
	let rs1_val = X(rs1);
	let rs2_val = X(rs2);
	let md_no = mregidx_to_mregno(md);
	var mr = rM(md_no);
	mr.dtype = INT_32;
	mr.width = rs1_val;
	mr.height = rs2_val;
	wM(md_no, mr);
	RETIRE_SUCCESS
}

mapping clause assembly = V2DDEF32(rs2, rs1, md)
	
<-> "v2ddef32" ^ spc() ^ reg_name(rs2) ^ sep() ^ reg_name(rs1) ^ sep() ^ mreg_name(md)
	when currentlyEnabled(Ext_Zimt)

union clause instruction = V2DLOC_RECT : (regidx, regidx, mregidx)

mapping clause encdec = V2DLOC_RECT(rs2, rs1, md)
	
<-> 0b0000000 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b001 @ encdec_mreg(md) @ 0b0101011
	when currentlyEnabled(Ext_Zimt)

function clause execute(V2DLOC_RECT(rs2, rs1, md)) = {
	let rs1_val = X(rs1);
	let rs2_val = X(rs2);
	let md_no = mregidx_to_mregno(md);
	var mr = rM(md_no);
	mr.prf_x = rs1_val;
	mr.prf_y = rs2_val;
	wM(md_no, mr);
	RETIRE_SUCCESS
}

mapping clause assembly = V2DLOC_RECT(rs2, rs1, md)
	
<-> "v2dloc.rect" ^ spc() ^ reg_name(rs2) ^ sep() ^ reg_name(rs1) ^ sep() ^ mreg_name(md)
	when currentlyEnabled(Ext_Zimt)

union clause instruction = V2DLOC_ROW : (regidx, regidx, mregidx)

mapping clause encdec = V2DLOC_ROW(rs2, rs1, md)
	
<-> 0b0000001 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b001 @ encdec_mreg(md) @ 0b0101011
	when currentlyEnabled(Ext_Zimt)

function clause execute(V2DLOC_ROW(rs2, rs1, md)) = {
	let rs1_val = X(rs1);
	let rs2_val = X(rs2);
	let md_no = mregidx_to_mregno(md);
	var mr = rM(md_no);
	mr.prf_x = rs1_val;
	mr.prf_y = rs2_val;
	wM(md_no, mr);
	RETIRE_SUCCESS
}

mapping clause assembly = V2DLOC_ROW(rs2, rs1, md)
	
<-> "v2dloc.row" ^ spc() ^ reg_name(rs2) ^ sep() ^ reg_name(rs1) ^ sep() ^ mreg_name(md)
	when currentlyEnabled(Ext_Zimt)

union clause instruction = V2DLOC_COL : (regidx, regidx, mregidx)

mapping clause encdec = V2DLOC_COL(rs2, rs1, md)
	
<-> 0b0000010 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b001 @ encdec_mreg(md) @ 0b0101011
	when currentlyEnabled(Ext_Zimt)

function clause execute(V2DLOC_COL(rs2, rs1, md)) = {
	let rs1_val = X(rs1);
	let rs2_val = X(rs2);
	let md_no = mregidx_to_mregno(md);
	var mr = rM(md_no);
	mr.prf_x = rs1_val;
	mr.prf_y = rs2_val;
	wM(md_no, mr);
	RETIRE_SUCCESS
}

mapping clause assembly = V2DLOC_COL(rs2, rs1, md)
	
<-> "v2dloc.col" ^ spc() ^ reg_name(rs2) ^ sep() ^ reg_name(rs1) ^ sep() ^ mreg_name(md)
	when currentlyEnabled(Ext_Zimt)

union clause instruction = V2DLOC_TRECT : (regidx, regidx, mregidx)

mapping clause encdec = V2DLOC_TRECT(rs2, rs1, md)
	
<-> 0b0000101 @ encdec_reg(rs2) @ encdec_reg(rs1) @ 0b001 @ encdec_mreg(md) @ 0b0101011
	when currentlyEnabled(Ext_Zimt)

function clause execute(V2DLOC_TRECT(rs2, rs1, md)) = {
	let rs1_val = X(rs1);
	let rs2_val = X(rs2);
	let md_no = mregidx_to_mregno(md);
	var mr = rM(md_no);
	mr.prf_x = rs1_val;
	mr.prf_y = rs2_val;
	wM(md_no, mr);
	RETIRE_SUCCESS
}

mapping clause assembly = V2DLOC_TRECT(rs2, rs1, md)
	
<-> "v2dloc.trect" ^ spc() ^ reg_name(rs2) ^ sep() ^ reg_name(rs1) ^ sep() ^ mreg_name(md)
	when currentlyEnabled(Ext_Zimt)

union clause instruction = V2DLD : (bits(12), regidx, mregidx)

mapping clause encdec = V2DLD(i11_0, rs1, md)
	
<-> i11_0 : bits(12) @ encdec_reg(rs1) @ 0b010 @ encdec_mreg(md) @ 0b0101011
	when currentlyEnabled(Ext_Zimt)

function clause execute(V2DLD(imm, rs1, md)) = {
	//let offset = imm;
	//let md = 0 LOAD(imm, rs1, rd, is_unsigned, width)
	let rs1_val = unsigned(X(rs1));
	let imm_ext = unsigned(imm);
	let md_no = mregidx_to_mregno(md);
	var mr = rM(md_no);
	var addr : xlenbits = sign_extend(imm);
	let height = unsigned(mr.height);
	let width = unsigned(mr.width);
	let start_x = unsigned(mr.prf_x);
	let start_y = unsigned(mr.prf_y);
	let w = imtSize(mr.dtype);
	let isUnsigned = imtIsUnsigned(mr.dtype);
	var i : int = 0;
	while(i < height) {
		var j : int = 0;
		while ( j < width ) {
			let idx = (start_x + i) * 1024 + start_y + j;
			if  idx >= 0 & idx < 1024 * 1024 & w >= 0 then {
				if w == 1 then {
					let res : bitvector(8) = match vmem_read(rs1, addr, 1, Load(Data), false, false, false) {
						Ok(data) => data,
						Err(e) => zeros(),
					};
					if isUnsigned then
						imt_mem[idx] = EXTZ(res)
					else
						imt_mem[idx] = EXTS(res);
				} else if w == 2 then {
					let res : bitvector(16) = match vmem_read(rs1, addr, 2, Load(Data), false, false, false) {
						Ok(data) => data,
						Err(e) => zeros(),
					};
					if isUnsigned then
						imt_mem[idx] = EXTZ(res)
					else
						imt_mem[idx] = EXTS(res);
				} else {
					let res : bitvector(32) = match vmem_read(rs1, addr, 4, Load(Data), false, false, false) {
						Ok(data) => data,
						Err(e) => zeros(),
					};
					imt_mem[idx] = res;
				};
			};
			addr = addr + w;
			j = j + 1;
		};
		i = i+1;
	};
	RETIRE_SUCCESS
}

mapping clause assembly = V2DLD(imm, rs1, md)
	
<-> "v2dld" ^ spc() ^ reg_name(rs1) ^ sep() ^ mreg_name(md) ^ sep() ^ hex_bits_12(imm)
	when currentlyEnabled(Ext_Zimt)

union clause instruction = V2DST : (bits(12), regidx, mregidx)

mapping clause encdec = V2DST(i11_0, rs1, md)
	
<-> i11_0 : bits(12) @ encdec_reg(rs1) @ 0b011 @ encdec_mreg(md) @ 0b0101011
	when currentlyEnabled(Ext_Zimt)

function clause execute(V2DST(imm, rs1, md)) = {
	let rs1_val = unsigned(X(rs1));
	let imm_ext = unsigned(imm);
	let md_no = mregidx_to_mregno(md);
	var mr = rM(md_no);
	var addr : xlenbits = sign_extend(imm);
	let height = unsigned(mr.height);
	let width = unsigned(mr.width);
	let start_x = unsigned(mr.prf_x);
	let start_y = unsigned(mr.prf_y);
	let w = imtSize(mr.dtype);
	let isUnsigned = imtIsUnsigned(mr.dtype);
	var i : int = 0;
	while(i < height) {
		var j : int = 0;
		while ( j < width ) {
			let idx = (start_x + i) * 1024 + start_y + j;
			if  idx >= 0 & idx < 1024 * 1024 & w >= 0 then {
				if w == 1 then {
					let data : bits(8) = imt_mem[idx][7 .. 0];
					let res : bool = match vmem_write(rs1, addr, 1, data, Store(Data), false, false, false) {
						Ok(_) => true,
						Err(e) => false,
					};
				} else if w == 2 then {
					let data : bits(16) = imt_mem[idx][15 .. 0];
					let res : bool = match vmem_write(rs1, addr, 2, data, Store(Data), false, false, false) {
						Ok(_) => true,
						Err(e) => false,
					};
				} else {
					let data : bits(32) = imt_mem[idx];
					let res : bool = match vmem_write(rs1, addr, 4, data, Store(Data), false, false, false) {
						Ok(_) => true,
						Err(e) => false,
					};
				};
			};
			addr = addr + w;
			j = j + 1;
		};
		i = i+1;
	};
	RETIRE_SUCCESS
}

mapping clause assembly = V2DST(imm, rs1, md)
	
<-> "v2dst" ^ spc() ^ reg_name(rs1) ^ sep() ^ mreg_name(md) ^ sep() ^ hex_bits_12(imm)
	when currentlyEnabled(Ext_Zimt)

union clause instruction = V2DADD_VV : (mregidx, mregidx, mregidx)

mapping clause encdec = V2DADD_VV(ms2, ms1, md)
	
<-> 0b0000001 @ encdec_mreg(ms2) @ encdec_mreg(ms1) @ 0b100 @ encdec_mreg(md) @ 0b0101011
	when currentlyEnabled(Ext_Zimt)

function clause execute(V2DADD_VV(ms2, ms1, md)) = {
	let m_op1 = rM(mregidx_to_mregno(ms1));
	let m_op2 = rM(mregidx_to_mregno(ms2));
	let m_rez = rM(mregidx_to_mregno(md));
	let height = unsigned(m_rez.height);
	let width = unsigned(m_rez.width);
	var i : int = 0;
	while(i < height) {
		var j : int = 0;
		while ( j < width ) {
			let idx_op1 = (unsigned(m_op1.prf_x) + i) * 1024 + unsigned(m_op1.prf_y) + j;
			let idx_op2 = (unsigned(m_op2.prf_x) + i) * 1024 + unsigned(m_op2.prf_y) + j;
			let idx_rez = (unsigned(m_rez.prf_x) + i) * 1024 + unsigned(m_rez.prf_y) + j;
			
			var op1 : int = 0;
			var op2 : int = 0;
			
			if  idx_op1 >= 0 & idx_op1 < 1024 * 1024 then
				if imtIsUnsigned(m_op1.dtype) then
					op1 = unsigned(imt_mem[idx_op1])
				else
					op1 = signed(imt_mem[idx_op1]);
			if  idx_op2 >= 0 & idx_op2 < 1024 * 1024 then
				if imtIsUnsigned(m_op2.dtype) then
					op2 = unsigned(imt_mem[idx_op2])
				else
					op2 = signed(imt_mem[idx_op2]);

			if  idx_rez >= 0 & idx_rez < 1024 * 1024 then
				imt_mem[idx_rez] = to_bits_truncate(32, op1 + op2);

			j = j + 1;
		};
		i = i+1;
	};
	RETIRE_SUCCESS
}

mapping clause assembly = V2DADD_VV(ms2, ms1, md)
	
<-> "v2dadd.vv" ^ spc() ^ mreg_name(ms2) ^ sep() ^ mreg_name(ms1) ^ sep() ^ mreg_name(md)
	when currentlyEnabled(Ext_Zimt)

union clause instruction = V2DSUB_VV : (mregidx, mregidx, mregidx)

mapping clause encdec = V2DSUB_VV(ms2, ms1, md)
	
<-> 0b0000010 @ encdec_mreg(ms2) @ encdec_mreg(ms1) @ 0b100 @ encdec_mreg(md) @ 0b0101011
	when currentlyEnabled(Ext_Zimt)

function clause execute(V2DSUB_VV(ms2, ms1, md)) = {
	let m_op1 = rM(mregidx_to_mregno(ms1));
	let m_op2 = rM(mregidx_to_mregno(ms2));
	let m_rez = rM(mregidx_to_mregno(md));
	let height = unsigned(m_rez.height);
	let width = unsigned(m_rez.width);
	var i : int = 0;
	while(i < height) {
		var j : int = 0;
		while ( j < width ) {
			let idx_op1 = (unsigned(m_op1.prf_x) + i) * 1024 + unsigned(m_op1.prf_y) + j;
			let idx_op2 = (unsigned(m_op2.prf_x) + i) * 1024 + unsigned(m_op2.prf_y) + j;
			let idx_rez = (unsigned(m_rez.prf_x) + i) * 1024 + unsigned(m_rez.prf_y) + j;
			
			var op1 : int = 0;
			var op2 : int = 0;
			
			if  idx_op1 >= 0 & idx_op1 < 1024 * 1024 then
				if imtIsUnsigned(m_op1.dtype) then
					op1 = unsigned(imt_mem[idx_op1])
				else
					op1 = signed(imt_mem[idx_op1]);
			if  idx_op2 >= 0 & idx_op2 < 1024 * 1024 then
				if imtIsUnsigned(m_op2.dtype) then
					op2 = unsigned(imt_mem[idx_op2])
				else
					op2 = signed(imt_mem[idx_op2]);

			if  idx_rez >= 0 & idx_rez < 1024 * 1024 then
				imt_mem[idx_rez] = to_bits_truncate(32, op1 - op2);

			j = j + 1;
		};
		i = i+1;
	};
	RETIRE_SUCCESS
}

mapping clause assembly = V2DSUB_VV(ms2, ms1, md)
	
<-> "v2dsub.vv" ^ spc() ^ mreg_name(ms2) ^ sep() ^ mreg_name(ms1) ^ sep() ^ mreg_name(md)
	when currentlyEnabled(Ext_Zimt)

union clause instruction = V2DCNV_VV : (mregidx, mregidx, mregidx)

mapping clause encdec = V2DCNV_VV(ms2, ms1, md)
	
<-> 0b0000100 @ encdec_mreg(ms2) @ encdec_mreg(ms1) @ 0b100 @ encdec_mreg(md) @ 0b0101011
	when currentlyEnabled(Ext_Zimt)

function clause execute(V2DCNV_VV(ms2, ms1, md)) = {
	let m_op1 = rM(mregidx_to_mregno(ms1));
	let m_op2 = rM(mregidx_to_mregno(ms2));
	let m_rez = rM(mregidx_to_mregno(md));
	let height = unsigned(m_op1.height) - unsigned(m_op2.height) + 1;
	let width = unsigned(m_op1.width) - unsigned(m_op2.width) + 1;
	let h = unsigned(m_op2.height);
	let w = unsigned(m_op2.width);
	var i : int = 0;
	while(i < height) {
		var j : int = 0;
		while ( j < width ) {
			var sum : int = 0;

			var ii : int = 0;
			while ( ii < h ) {
				var jj : int = 0;
				while ( jj < w ) {
					let idx_op1 = (unsigned(m_op1.prf_x) + i + ii) * 1024 + unsigned(m_op1.prf_y) + j + jj;
					let idx_op2 = (unsigned(m_op2.prf_x) + ii) * 1024 + unsigned(m_op2.prf_y) + jj;
					
					var op1 : int = 0;
					var op2 : int = 0;
					
					if  idx_op1 >= 0 & idx_op1 < 1024 * 1024 then
						if imtIsUnsigned(m_op1.dtype) then
							op1 = unsigned(imt_mem[idx_op1])
						else
							op1 = signed(imt_mem[idx_op1]);
					if  idx_op2 >= 0 & idx_op2 < 1024 * 1024 then
						if imtIsUnsigned(m_op2.dtype) then
							op2 = unsigned(imt_mem[idx_op2])
						else
							op2 = signed(imt_mem[idx_op2]);

					sum = sum + op1 * op2;
					jj = jj + 1;
				};
				ii = ii + 1;
			};
			
			let idx_rez = (unsigned(m_rez.prf_x) + i) * 1024 + unsigned(m_rez.prf_y) + j;
			
			if  idx_rez >= 0 & idx_rez < 1024 * 1024 then
				imt_mem[idx_rez] = to_bits_truncate(32, sum);

			j = j + 1;
		};
		i = i+1;
	};
	RETIRE_SUCCESS
}

mapping clause assembly = V2DCNV_VV(ms2, ms1, md)
	
<-> "v2dcnv.vv" ^ spc() ^ mreg_name(ms2) ^ sep() ^ mreg_name(ms1) ^ sep() ^ mreg_name(md)
	when currentlyEnabled(Ext_Zimt)

union clause instruction = V2DDIV_VV : (mregidx, mregidx, mregidx)

mapping clause encdec = V2DDIV_VV(ms2, ms1, md)
	
<-> 0b0001000 @ encdec_mreg(ms2) @ encdec_mreg(ms1) @ 0b100 @ encdec_mreg(md) @ 0b0101011
	when currentlyEnabled(Ext_Zimt)

function clause execute(V2DDIV_VV(ms2, ms1, md)) = {
	let m_op1 = rM(mregidx_to_mregno(ms1));
	let m_op2 = rM(mregidx_to_mregno(ms2));
	let m_rez = rM(mregidx_to_mregno(md));
	let height = unsigned(m_rez.height);
	let width = unsigned(m_rez.width);
	var i : int = 0;
	while(i < height) {
		var j : int = 0;
		while ( j < width ) {
			let idx_op1 = (unsigned(m_op1.prf_x) + i) * 1024 + unsigned(m_op1.prf_y) + j;
			let idx_op2 = (unsigned(m_op2.prf_x) + i) * 1024 + unsigned(m_op2.prf_y) + j;
			let idx_rez = (unsigned(m_rez.prf_x) + i) * 1024 + unsigned(m_rez.prf_y) + j;
			
			var op1 : int = 0;
			var op2 : int = 0;
			
			if  idx_op1 >= 0 & idx_op1 < 1024 * 1024 then
				if imtIsUnsigned(m_op1.dtype) then
					op1 = unsigned(imt_mem[idx_op1])
				else
					op1 = signed(imt_mem[idx_op1]);
			if  idx_op2 >= 0 & idx_op2 < 1024 * 1024 then
				if imtIsUnsigned(m_op2.dtype) then
					op2 = unsigned(imt_mem[idx_op2])
				else
					op2 = signed(imt_mem[idx_op2]);

			if  idx_rez >= 0 & idx_rez < 1024 * 1024 then {
				//let quotient = if op2 == 0 then -1 else quot_round_zero(op1, op2);
				imt_mem[idx_rez] = to_bits_truncate(32, 0);
			};

			j = j + 1;
		};
		i = i+1;
	};
	RETIRE_SUCCESS
}

mapping clause assembly = V2DDIV_VV(ms2, ms1, md)
	
<-> "v2ddiv.vv" ^ spc() ^ mreg_name(ms2) ^ sep() ^ mreg_name(ms1) ^ sep() ^ mreg_name(md)
	when currentlyEnabled(Ext_Zimt)

union clause instruction = V2DMUL_VV : (mregidx, mregidx, mregidx)

mapping clause encdec = V2DMUL_VV(ms2, ms1, md)
	
<-> 0b0010000 @ encdec_mreg(ms2) @ encdec_mreg(ms1) @ 0b100 @ encdec_mreg(md) @ 0b0101011
	when currentlyEnabled(Ext_Zimt)

function clause execute(V2DMUL_VV(ms2, ms1, md)) = {
	let m_op1 = rM(mregidx_to_mregno(ms1));
	let m_op2 = rM(mregidx_to_mregno(ms2));
	let m_rez = rM(mregidx_to_mregno(md));
	let height = unsigned(m_rez.height);
	let width = unsigned(m_rez.width);
	let inner = unsigned(m_op1.width);
	var i : int = 0;
	while(i < height) {
		var j : int = 0;
		while ( j < width ) {
			var k : int = 0;
			var sum : int = 0;
			while ( k < inner ) {
				let idx_op1 = (unsigned(m_op1.prf_x) + i) * 1024 + unsigned(m_op1.prf_y) + k;
				let idx_op2 = (unsigned(m_op2.prf_x) + k) * 1024 + unsigned(m_op2.prf_y) + j;
				
				var op1 : int = 0;
				var op2 : int = 0;
				
				if  idx_op1 >= 0 & idx_op1 < 1024 * 1024 then
					if imtIsUnsigned(m_op1.dtype) then
						op1 = unsigned(imt_mem[idx_op1])
					else
						op1 = signed(imt_mem[idx_op1]);
				if  idx_op2 >= 0 & idx_op2 < 1024 * 1024 then
					if imtIsUnsigned(m_op2.dtype) then
						op2 = unsigned(imt_mem[idx_op2])
					else
						op2 = signed(imt_mem[idx_op2]);

				sum = sum + op1 * op2;
				k = k + 1;
			};
			let idx_rez = (unsigned(m_rez.prf_x) + i) * 1024 + unsigned(m_rez.prf_y) + j;
			
			if  idx_rez >= 0 & idx_rez < 1024 * 1024 then
				imt_mem[idx_rez] = to_bits_truncate(32, sum);

			j = j + 1;
		};
		i = i+1;
	};
	RETIRE_SUCCESS
}

mapping clause assembly = V2DMUL_VV(ms2, ms1, md)
	
<-> "v2dmul.vv" ^ spc() ^ mreg_name(ms2) ^ sep() ^ mreg_name(ms1) ^ sep() ^ mreg_name(md)
	when currentlyEnabled(Ext_Zimt)

union clause instruction = V2DSMUL_VV : (mregidx, mregidx, mregidx)

mapping clause encdec = V2DSMUL_VV(ms2, ms1, md)
	
<-> 0b0110000 @ encdec_mreg(ms2) @ encdec_mreg(ms1) @ 0b100 @ encdec_mreg(md) @ 0b0101011
	when currentlyEnabled(Ext_Zimt)

function clause execute(V2DSMUL_VV(ms2, ms1, md)) = {
	let m_op1 = rM(mregidx_to_mregno(ms1));
	let m_op2 = rM(mregidx_to_mregno(ms2));
	let m_rez = rM(mregidx_to_mregno(md));
	let height = unsigned(m_rez.height);
	let width = unsigned(m_rez.width);
	var i : int = 0;
	while(i < height) {
		var j : int = 0;
		while ( j < width ) {
			let idx_op1 = (unsigned(m_op1.prf_x) + i) * 1024 + unsigned(m_op1.prf_y) + j;
			let idx_op2 = (unsigned(m_op2.prf_x) + i) * 1024 + unsigned(m_op2.prf_y) + j;
			let idx_rez = (unsigned(m_rez.prf_x) + i) * 1024 + unsigned(m_rez.prf_y) + j;
			
			var op1 : int = 0;
			var op2 : int = 0;
			
			if  idx_op1 >= 0 & idx_op1 < 1024 * 1024 then
				if imtIsUnsigned(m_op1.dtype) then
					op1 = unsigned(imt_mem[idx_op1])
				else
					op1 = signed(imt_mem[idx_op1]);
			if  idx_op2 >= 0 & idx_op2 < 1024 * 1024 then
				if imtIsUnsigned(m_op2.dtype) then
					op2 = unsigned(imt_mem[idx_op2])
				else
					op2 = signed(imt_mem[idx_op2]);

			if  idx_rez >= 0 & idx_rez < 1024 * 1024 then
				imt_mem[idx_rez] = to_bits_truncate(32, op1 * op2);

			j = j + 1;
		};
		i = i+1;
	};
	RETIRE_SUCCESS
}

mapping clause assembly = V2DSMUL_VV(ms2, ms1, md)
	
<-> "v2dsmul.vv" ^ spc() ^ mreg_name(ms2) ^ sep() ^ mreg_name(ms1) ^ sep() ^ mreg_name(md)
	when currentlyEnabled(Ext_Zimt)

union clause instruction = V2DADD_VS : (regidx, mregidx, mregidx)

mapping clause encdec = V2DADD_VS(rs2, ms1, md)
	
<-> 0b0000001 @ encdec_reg(rs2) @ encdec_mreg(ms1) @ 0b101 @ encdec_mreg(md) @ 0b0101011
	when currentlyEnabled(Ext_Zimt)

function clause execute(V2DADD_VS(rs2, ms1, md)) = {
	let m_op1 = rM(mregidx_to_mregno(ms1));
	let m_rez = rM(mregidx_to_mregno(md));
	let height = unsigned(m_rez.height);
	let width = unsigned(m_rez.width);
	var op2 : int = 0;
	if imtIsUnsigned(m_op1.dtype) then
		op2 = unsigned(X(rs2))
	else
		op2 = signed(X(rs2));
	var i : int = 0;
	while(i < height) {
		var j : int = 0;
		while ( j < width ) {
			let idx_op1 = (unsigned(m_op1.prf_x) + i) * 1024 + unsigned(m_op1.prf_y) + j;
			let idx_rez = (unsigned(m_rez.prf_x) + i) * 1024 + unsigned(m_rez.prf_y) + j;
			
			var op1 : int = 0;
			
			if  idx_op1 >= 0 & idx_op1 < 1024 * 1024 then
				if imtIsUnsigned(m_op1.dtype) then
					op1 = unsigned(imt_mem[idx_op1])
				else
					op1 = signed(imt_mem[idx_op1]);

			if  idx_rez >= 0 & idx_rez < 1024 * 1024 then
				imt_mem[idx_rez] = to_bits_truncate(32, op1 + op2);

			j = j + 1;
		};
		i = i+1;
	};
	RETIRE_SUCCESS
}

mapping clause assembly = V2DADD_VS(rs2, ms1, md)
	
<-> "v2dadd.vs" ^ spc() ^ reg_name(rs2) ^ sep() ^ mreg_name(ms1) ^ sep() ^ mreg_name(md)
	when currentlyEnabled(Ext_Zimt)

union clause instruction = V2DSUB_VS : (regidx, mregidx, mregidx)

mapping clause encdec = V2DSUB_VS(rs2, ms1, md)
	
<-> 0b0000010 @ encdec_reg(rs2) @ encdec_mreg(ms1) @ 0b101 @ encdec_mreg(md) @ 0b0101011
	when currentlyEnabled(Ext_Zimt)

function clause execute(V2DSUB_VS(rs2, ms1, md)) = {
	let m_op1 = rM(mregidx_to_mregno(ms1));
	let m_rez = rM(mregidx_to_mregno(md));
	let height = unsigned(m_rez.height);
	let width = unsigned(m_rez.width);
	var op2 : int = 0;
	if imtIsUnsigned(m_op1.dtype) then
		op2 = unsigned(X(rs2))
	else
		op2 = signed(X(rs2));
	var i : int = 0;
	while(i < height) {
		var j : int = 0;
		while ( j < width ) {
			let idx_op1 = (unsigned(m_op1.prf_x) + i) * 1024 + unsigned(m_op1.prf_y) + j;
			let idx_rez = (unsigned(m_rez.prf_x) + i) * 1024 + unsigned(m_rez.prf_y) + j;
			
			var op1 : int = 0;
			
			if  idx_op1 >= 0 & idx_op1 < 1024 * 1024 then
				if imtIsUnsigned(m_op1.dtype) then
					op1 = unsigned(imt_mem[idx_op1])
				else
					op1 = signed(imt_mem[idx_op1]);

			if  idx_rez >= 0 & idx_rez < 1024 * 1024 then
				imt_mem[idx_rez] = to_bits_truncate(32, op1 - op2);

			j = j + 1;
		};
		i = i+1;
	};
	RETIRE_SUCCESS
}

mapping clause assembly = V2DSUB_VS(rs2, ms1, md)
	
<-> "v2dsub.vs" ^ spc() ^ reg_name(rs2) ^ sep() ^ mreg_name(ms1) ^ sep() ^ mreg_name(md)
	when currentlyEnabled(Ext_Zimt)

union clause instruction = V2DDIV_VS : (regidx, mregidx, mregidx)

mapping clause encdec = V2DDIV_VS(rs2, ms1, md)
	
<-> 0b0001000 @ encdec_reg(rs2) @ encdec_mreg(ms1) @ 0b101 @ encdec_mreg(md) @ 0b0101011
	when currentlyEnabled(Ext_Zimt)

function clause execute(V2DDIV_VS(rs2, ms1, md)) = {
	let m_op1 = rM(mregidx_to_mregno(ms1));
	let m_rez = rM(mregidx_to_mregno(md));
	let height = unsigned(m_rez.height);
	let width = unsigned(m_rez.width);
	var op2 : int = 0;
	if imtIsUnsigned(m_op1.dtype) then
		op2 = unsigned(X(rs2))
	else
		op2 = signed(X(rs2));
	var i : int = 0;
	while(i < height) {
		var j : int = 0;
		while ( j < width ) {
			let idx_op1 = (unsigned(m_op1.prf_x) + i) * 1024 + unsigned(m_op1.prf_y) + j;
			let idx_rez = (unsigned(m_rez.prf_x) + i) * 1024 + unsigned(m_rez.prf_y) + j;
			
			var op1 : int = 0;
			
			if  idx_op1 >= 0 & idx_op1 < 1024 * 1024 then
				if imtIsUnsigned(m_op1.dtype) then
					op1 = unsigned(imt_mem[idx_op1])
				else
					op1 = signed(imt_mem[idx_op1]);

			if  idx_rez >= 0 & idx_rez < 1024 * 1024 then {
				//let quotient = if op2 == 0 then -1 else quot_round_zero(op1, op2);
				imt_mem[idx_rez] = to_bits_truncate(32, 0);
			};

			j = j + 1;
		};
		i = i+1;
	};
	RETIRE_SUCCESS
}

mapping clause assembly = V2DDIV_VS(rs2, ms1, md)
	
<-> "v2ddiv.vs" ^ spc() ^ reg_name(rs2) ^ sep() ^ mreg_name(ms1) ^ sep() ^ mreg_name(md)
	when currentlyEnabled(Ext_Zimt)

union clause instruction = V2DMUL_VS : (regidx, mregidx, mregidx)

mapping clause encdec = V2DMUL_VS(rs2, ms1, md)
	
<-> 0b0010000 @ encdec_reg(rs2) @ encdec_mreg(ms1) @ 0b101 @ encdec_mreg(md) @ 0b0101011
	when currentlyEnabled(Ext_Zimt)

function clause execute(V2DMUL_VS(rs2, ms1, md)) = {
	let m_op1 = rM(mregidx_to_mregno(ms1));
	let m_rez = rM(mregidx_to_mregno(md));
	let height = unsigned(m_rez.height);
	let width = unsigned(m_rez.width);
	var op2 : int = 0;
	if imtIsUnsigned(m_op1.dtype) then
		op2 = unsigned(X(rs2))
	else
		op2 = signed(X(rs2));
	var i : int = 0;
	while(i < height) {
		var j : int = 0;
		while ( j < width ) {
			let idx_op1 = (unsigned(m_op1.prf_x) + i) * 1024 + unsigned(m_op1.prf_y) + j;
			let idx_rez = (unsigned(m_rez.prf_x) + i) * 1024 + unsigned(m_rez.prf_y) + j;
			
			var op1 : int = 0;
			
			if  idx_op1 >= 0 & idx_op1 < 1024 * 1024 then
				if imtIsUnsigned(m_op1.dtype) then
					op1 = unsigned(imt_mem[idx_op1])
				else
					op1 = signed(imt_mem[idx_op1]);

			if  idx_rez >= 0 & idx_rez < 1024 * 1024 then
				imt_mem[idx_rez] = to_bits_truncate(32, op1 * op2);

			j = j + 1;
		};
		i = i+1;
	};
	RETIRE_SUCCESS
}

mapping clause assembly = V2DMUL_VS(rs2, ms1, md)
	
<-> "v2dmul.vs" ^ spc() ^ reg_name(rs2) ^ sep() ^ mreg_name(ms1) ^ sep() ^ mreg_name(md)
	when currentlyEnabled(Ext_Zimt)


union clause instruction = V2DSLL_VS : (regidx, mregidx, mregidx)

mapping clause encdec = V2DSLL_VS(rs2, ms1, md)
	
<-> 0b0001001 @ encdec_reg(rs2) @ encdec_mreg(ms1) @ 0b101 @ encdec_mreg(md) @ 0b0101011
	when currentlyEnabled(Ext_Zimt)

function clause execute(V2DSLL_VS(rs2, ms1, md)) = {
	let m_op1 = rM(mregidx_to_mregno(ms1));
	let m_rez = rM(mregidx_to_mregno(md));
	let height = unsigned(m_rez.height);
	let width = unsigned(m_rez.width);
	var op2 = unsigned(X(rs2));
	var i : int = 0;
	while(i < height) {
		var j : int = 0;
		while ( j < width ) {
			let idx_op1 = (unsigned(m_op1.prf_x) + i) * 1024 + unsigned(m_op1.prf_y) + j;
			let idx_rez = (unsigned(m_rez.prf_x) + i) * 1024 + unsigned(m_rez.prf_y) + j;
			
			var op1 : int = 0;
			
			if  idx_op1 >= 0 & idx_op1 < 1024 * 1024 then
				if imtIsUnsigned(m_op1.dtype) then
					op1 = unsigned(imt_mem[idx_op1])
				else
					op1 = signed(imt_mem[idx_op1]);

			if  idx_rez >= 0 & idx_rez < 1024 * 1024 then
				imt_mem[idx_rez] = to_bits_truncate(32, _shl_int(op1, op2));

			j = j + 1;
		};
		i = i+1;
	};
	RETIRE_SUCCESS
}

mapping clause assembly = V2DSLL_VS(rs2, ms1, md)
	
<-> "v2dsll.vs" ^ spc() ^ reg_name(rs2) ^ sep() ^ mreg_name(ms1) ^ sep() ^ mreg_name(md)
	when currentlyEnabled(Ext_Zimt)


union clause instruction = V2DSRL_VS : (regidx, mregidx, mregidx)

mapping clause encdec = V2DSRL_VS(rs2, ms1, md)
	
<-> 0b0001010 @ encdec_reg(rs2) @ encdec_mreg(ms1) @ 0b101 @ encdec_mreg(md) @ 0b0101011
	when currentlyEnabled(Ext_Zimt)

function clause execute(V2DSRL_VS(rs2, ms1, md)) = {
	let m_op1 = rM(mregidx_to_mregno(ms1));
	let m_rez = rM(mregidx_to_mregno(md));
	let height = unsigned(m_rez.height);
	let width = unsigned(m_rez.width);
	var op2 = unsigned(X(rs2));
	var i : int = 0;
	while(i < height) {
		var j : int = 0;
		while ( j < width ) {
			let idx_op1 = (unsigned(m_op1.prf_x) + i) * 1024 + unsigned(m_op1.prf_y) + j;
			let idx_rez = (unsigned(m_rez.prf_x) + i) * 1024 + unsigned(m_rez.prf_y) + j;
			
			var op1 : int = 0;
			
			if  idx_op1 >= 0 & idx_op1 < 1024 * 1024 then
				if imtIsUnsigned(m_op1.dtype) then
					op1 = unsigned(imt_mem[idx_op1])
				else
					op1 = signed(imt_mem[idx_op1]);

			if  idx_rez >= 0 & idx_rez < 1024 * 1024 then
				imt_mem[idx_rez] = to_bits_truncate(32, _shr_int(op1, op2));

			j = j + 1;
		};
		i = i+1;
	};
	RETIRE_SUCCESS
}

mapping clause assembly = V2DSRL_VS(rs2, ms1, md)
	
<-> "v2dsrl.vs" ^ spc() ^ reg_name(rs2) ^ sep() ^ mreg_name(ms1) ^ sep() ^ mreg_name(md)
	when currentlyEnabled(Ext_Zimt)


union clause instruction = V2DSRA_VS : (regidx, mregidx, mregidx)

mapping clause encdec = V2DSRA_VS(rs2, ms1, md)
	
<-> 0b0001011 @ encdec_reg(rs2) @ encdec_mreg(ms1) @ 0b101 @ encdec_mreg(md) @ 0b0101011
	when currentlyEnabled(Ext_Zimt)

function clause execute(V2DSRA_VS(rs2, ms1, md)) = {
		let m_op1 = rM(mregidx_to_mregno(ms1));
	let m_rez = rM(mregidx_to_mregno(md));
	let height = unsigned(m_rez.height);
	let width = unsigned(m_rez.width);
	var op2 = unsigned(X(rs2));
	var i : int = 0;
	while(i < height) {
		var j : int = 0;
		while ( j < width ) {
			let idx_op1 = (unsigned(m_op1.prf_x) + i) * 1024 + unsigned(m_op1.prf_y) + j;
			let idx_rez = (unsigned(m_rez.prf_x) + i) * 1024 + unsigned(m_rez.prf_y) + j;
			
			var op1 : int = 0;
			
			if  idx_op1 >= 0 & idx_op1 < 1024 * 1024 then
				if imtIsUnsigned(m_op1.dtype) then
					op1 = unsigned(imt_mem[idx_op1])
				else
					op1 = signed(imt_mem[idx_op1]);

			if  idx_rez >= 0 & idx_rez < 1024 * 1024 then
				imt_mem[idx_rez] = to_bits_truncate(32, _shr_int(op1, op2));

			j = j + 1;
		};
		i = i+1;
	};
	RETIRE_SUCCESS
}

mapping clause assembly = V2DSRA_VS(rs2, ms1, md)
	
<-> "v2dsra.vs" ^ spc() ^ reg_name(rs2) ^ sep() ^ mreg_name(ms1) ^ sep() ^ mreg_name(md)
	when currentlyEnabled(Ext_Zimt)


